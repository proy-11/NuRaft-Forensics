
NuRaft-Forensics
======

NuRaft library with forensics support.

Forensics
---------
### Log Replication

- *Hash Pointers*: A hash pointer cache (hash_cache_) is maintained in each node to store the hash pointers of log entries between the last committed entry and the last appended entry. Any append_entries request whose last entry is within the cache will include the hash pointer in the first entry of the request. Followers will verify the hash pointer before appending the entries to their logs. If verification fails, the follower will set the result code to cmd_result_code::BAD_CHAIN.

- *Leader Stamp*: The leader_sig_ field in the log_entry class is used to lock the leader into the log entries it is sharing. The leader generates the stamp, which is included in the second entry (if the first entry is used for sharing hash pointers) of the append_entries request.

- *Commitment Certificate*: The latest committed log entry's Commitment Certificate (CC) is stored in commit_cert_, while working_certs_ stores CCs that are still waiting for follower acknowledgment. The leader waits for a majority of followers to reply with their signatures on the log entry before committing. Once the majority is achieved, the leader replaces the commit_cert_ with the next CC in working_certs_ and makes the log entry committable.


### Leader Election

Leader election lists contain the vote request message and vote granters' signatures on the request for each term. The election lists are stored in a `std::unordered_map<ulong, ptr<leader_certificate>>` object, where the key is the term index and the value is a leader certificate. The `leader_certificate` is declared in `src/leader_certificate.hxx`. Any updates to the election lists are written to `[forensics_dir]/el_[timestamp]_p[node_id].dat` immediately.

The process of node becoming leader is:

1. The leader sends a vote request message to all followers.
2. Followers reply with their signatures on the request (instead of just saying OK).
3. When the leader collects a majority of signatures, it ensemble the signatures into a leader certificate and shares it with all followers. This node becomes the leader for the term.


### Output File Parser

The following Python scripts are provided to parse the output files generated by the forensics feature:

- Log entry: `scripts/forensics/log_entries.py`
- Election list: `scripts/forensics/election_lists.py`
- Leader signatures: `scripts/forensics/leader_signatures.py`

Additional Forensics Tests
-------------------------
The following tests are added to the existing test suite:

### Liveness Test

This test checks if the basic Raft protocol is functioning correctly. It verifies that the system operates properly when a node goes down and then comes back up.

#### How to run:

After the system is built, run the following command:

```sh
$ ./tests/forensics_test/nodes_down_test.sh
```

#### Test details:

```
0s launched
10s follower freeze
30s follower comes back
40s leader freeze
60s leader comes back
70s stop and check disk file validity 
```

#### Implementation details:

The network backend uses Asio (real network). Node downtime is simulated by suspending the server process, and the node is brought back up by resuming the server process. After the test is completed, disk file consistency is checked.

### Split Brain Test

This test evaluates the system's ability to handle a split-brain scenario. It creates two groups of nodes that cannot communicate with each other, but includes a malicious node that can communicate with both groups. This malicious node becomes the leader and attempts to append different messages to each group. The test checks for evidence of the leader being accused of appending malicious messages to different groups.

#### How to run:

Since some modifications to the original NuRaft are necessary, this test is only implemented in the attack-test branch. After switching to the attack-test branch and building the system, run the following command:

```sh
$ ./tests/forensics_test/split_brain_test.sh
```

#### Differences between the attack-test branch and the main branch:

Some `raft_server` member functions need to be declared as `virtual` to be overridden in the `mal_raft_server` class. Although these changes should not affect the system's logic, they may introduce some runtime overhead. To avoid this overhead, use the main branch.

#### Test details

- All 5 nodes (1, 2, 3, 4, and 5) start.
- Server 1 becomes the leader.
- Server 1 appends 1000 entries with payloads 0, 2, 4, ... 1998.
- Network partitioned:
  - Group 1: Server 1, 2, and 3.
  - Group 2: Server 3, 4, and 5.
- Server 3 becomes the leader.
- Server 3 appends 1000 entries:
  - To Group 1 with payloads 2000, 2002, 2004, ... 3998.
  - To Group 2 with payloads 2001, 2003, 2005, ... 3999.
- All nodes shut down.


#### Implementation details:

The test uses `FakeNetwork` as the backend. The malicious node is implemented as a `mal_raft_server` class that inherits from the `raft_server` class.

How to Build
------------
#### 1. Install `cmake` and `openssl`: ####

* Ubuntu
```sh
$ sudo apt-get install cmake openssl libssl-dev libz-dev
```

* OSX
```sh
$ brew install cmake
$ brew install openssl
```
* Windows
    * Download and install [CMake](https://cmake.org/download/).
    * Currently, we do not support SSL for Windows.


#### 2. Install `boost` library: ####

See the [official documentation](https://www.boost.org/doc/libs/1_80_0/more/getting_started/index.html) for reference. 

#### 3. Fetch [Asio](https://github.com/chriskohlhoff/asio) library: ####

* Linux & OSX
```sh
$ ./prepare.sh
```
* Windows
    * Clone [Asio](https://github.com/chriskohlhoff/asio) `asio-1-12-0`
      into the project directory.
```sh
C:\NuRaft> git clone https://github.com/chriskohlhoff/asio -b asio-1-12-0
```

#### 3. Build static library, tests, and examples: ####

* Linux & OSX
```sh
$ mkdir build
$ cd build
build$ cmake ../
build$ make
```

Run unit tests
```sh
build$ ./runtests.sh
```

* Windows:
```sh
C:\NuRaft> mkdir build
C:\NuRaft> cd build
C:\NuRaft\build> cmake -G "NMake Makefiles" ..\
C:\NuRaft\build> nmake
```

You may need to run `vcvars` script first in your `build` directory. For example (it depends on how you installed MSVC):
```sh
C:\NuRaft\build> c:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Auxiliary\Build\vcvars64.bat
```

Supported Platforms
-------------------
* Ubuntu (tested on 14.04, 16.04, and 18.04)
* Centos (tested on 7)
* OSX (tested on 10.13 and 10.14)

3rd Party Code
--------------
1. URL: https://github.com/datatechnology/cornerstone<br>
License: https://github.com/datatechnology/cornerstone/blob/master/LICENSE<br>
Originally licensed under the Apache 2.0 license.

